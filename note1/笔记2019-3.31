{"code":200,"msg":"201","obj":"5404"}
页面修改后ctrl+f9：重新编译

servlt无法使用@Autowrite注解


hashcode和equals：未重写时，先为对象生成hashcode，放入哈希表中，如果hashcode重复，用equals判断是否是同一对象。


多态的理解：多态分为编译时多态--方法的重载，运行时多态--根据实例类型来调用方法

泛型中extend和super的区别：extend是上届，super是下届
如果要从集合中读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；(Producer Extends) 
如果要从集合中写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；(Consumer Super) 
如果既要存又要取，那么就不要使用任何通配符。

a=a+b	a+=b； +=是一个操作符号，且+=左侧只能是基础类型和String，short和int类型时第一个需要强转，第二个不用，自动向高精度进行数据类型转换。

反射：通过创建Class对象，加载对应的方法和属性	




java中实现多肽的机制：类信息存在方法区中，类信息中有一个指针，指向记录该类方法入口的表，表中的每一项都是指向相应方发的指针，该表中只有非私有的和非静态的方法才会出现
***************************
由于以上方法的排列特性（Object——父类——子类），使得方法表的偏移量总是固定的。例如，对于任何类来说，其方法表中equals方法的偏移量总是一个定值，所有继承某父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。
前面说过，方法表中的表项都是指向该类对应方法的指针，这里就开始了多态的实现：
假设Class A是Class B的子类，并且A改写了B的方法method()，那么在B的方法表中，method方法的指针指向的就是B的method方法入口。
而对于A来说，它的方法表中的method方法则会指向其自身的method方法而非其父类的（这在类加载器载入该类时已经保证，同时JVM会保证总是能从对象引用指向正确的类型信息）。
接口会更复杂
**************************


inern 方法：
1.6-->调用方法后将字符串对象的字符串在常量池中查找，如果没有就将字符串存到常量池中
1.7-->调用方法后，再次创建String对象会直接在常量池中寻找，如果有就将引用拿过来，减少对象的创建

编译器常量：赋予final的常量，在编译期就已经确定

异常链：捕获一个异常，然后抛出另一个异常

Daemon线程:守护线程，如jvm垃圾清理线程

线程组：管理线程和线程组，官方弃用了其主要方法，且非线程安全

java中用到的线程调度算法:抢占式，根据优先级分配cpu资源，同优先级根据先进先出

同步块和同步方法：同步方法锁的是整个this对象，静态同步方法锁的是.class的对象

乐观锁和悲观锁：乐观锁即冲突一般不会发生，如果发生冲突，让用户返回错误信息
		悲观锁即冲突一定会发生，读的时候，为更新枷锁之后再来的读操作都会等待

sleep和wait的区别：sleep是线程的方法，线程进入等待状态，不会释放对象锁，在任何地方使用。wait是Object的方法，释放对象锁，进入等待此对象的等待锁定池，当对象再次调用notify方法才会重新有机会获取对象锁

控制并发访问：信号量。。。





