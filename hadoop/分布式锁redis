数据库表（添加或删除一条记录） 缓存（过期时间） zookeeper（监听事件）
单点：Redis集群，并且每个主节点还会有从节点。由于Redis的主从复制是异步的，因此上述方案在Redis集群的环境下也是有问题的。
redis:
1.查key对应value的值，不存在，setkey的值，拿到锁
存在，等待，问题：宕机（设置一个过期的值），无法释放锁，获取的锁不是原子操作，导致多个客户端获取同一把锁
2.Redis提供了一个只有在某个key不存在的情况下才会设置key的值的原子命令，该命令也能设置key值过期时间，因此使用该命令，不存在上述方案出现的问题，该命令为：

SET my_key my_value NX PX milliseconds
问题：超时后未释放锁，导致释放其他客户端的锁

3设置随机的值，比对随机值，相等时才释放锁
问题：获取随机的值后，【延迟几秒在delete会释放其他客户端的锁

4在Redis中执行原子操作不止有通过官方提供的命令的方式，还有另外一种方式，就是Lua脚本
由于Lua脚本的原子性，在Redis执行该脚本的过程中，其他客户端的命令都需要等待该Lua脚本执行完才能执行，所以不会出现方案三所说的问题。至此，使用Redis实现分布式锁的方案就相对完善了。
