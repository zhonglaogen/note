程序计数器
虚拟机栈：局部变量表，操作数栈
本地方法栈
堆
方法区

gc：寻找清除对象：引用计数器，gcroot可达性分析（两次）
stw：全局暂停，所有java代码停止，native代码可以执行，但不能和jvm交互
通常由于gc引起，1dum线程2死锁检查3堆dump

垃圾收集器：
1（serial）串性：单线程。慢，stw时间较长
参数-XX：+UseSerialGC
新生代老年带使用，新生代：复制，老年代：标记整理
2 （parnew）新生代并行，老年代串性
参数：-XX:userparnewGC
3 parallel
-XX：+useparallelgc使用parallel收集器+老年代串性
-XX:+useparalleloldgc使用paralle收集器+老年代并行
4 cms收集器（并发标记清除）
重新标记还要整理
并发截断会降低吞吐量
老年代收集器，新生代用parnew
-XX:+useconmarkSweepgc
流程：
1初始标记：根可以直接关联的对象，速度快（非并发）
2并发标记：主要标记过程，标记全部对象（和用户线程一起）
3重新标记：由于并发标记时用户线程在运行，在标记一次修正（非并发）
4并发清除：基于标记结果进清除（和用户线程一起）
尽可能的降低停顿，
会影响整体的吞吐量和性能
比如：用户线程运行中，分一半cpu给gc，性能降低
清理不彻底：用户线程还在运行，会产生新垃圾
和用户线程一起运行，不能在空间快满的时候运行


