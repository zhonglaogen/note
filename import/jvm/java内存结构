程序计数器
虚拟机栈：栈帧 局部变量表，操作数栈,，动态链接（方法区中具体方法的地址），返回地址
本地方法栈
堆
方法区：（被jvm加载的类信息、常量、静
态变量、即时编译器编译后的代码等数据. HotSpot VM 把 GC 分代收集扩展至方法区, 即使用 Java
堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存,
而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型
的卸载, 因此收益一般很小)。
运行时常量池(Runtime Constant Pool)是方法区的一部分。Class 文件中除了有类的版
本、字段、方法、接口等描述等信息外,还有一项信息是常量池
13/04/2018
Page 23 of 283(Constant Pool Table),用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加
载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分(自然也包括常量
池)的格式都有严格的规定,每一个字节用于存储哪种数据都必须符合规范上的要求,这样才会
被虚拟机认可、装载和执行。）

运行时常量池：：字面量（文本字符串，被声明为final的常量，基本数据类型）：：符号引用（类的结构和完全限定名，字段名和描述符，方法名和描述符）
转移到堆的是字符串常量池，静态变量
方法区：被jvm加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

gc：寻找清除对象：引用计数器，gcroot可达性分析（两次）
stw：全局暂停，所有java代码停止，native代码可以执行，但不能和jvm交互
通常由于gc引起，1dum线程2死锁检查3堆dump

垃圾收集器：
1（serial）串性：单线程。慢，stw时间较长
参数-XX：+UseSerialGC
新生代老年带使用，新生代：复制，老年代：标记整理
2 （parnew）新生代并行，老年代串性
参数：-XX:userparnewGC
3 parallel
-XX：+useparallelgc使用parallel收集器+老年代串性
-XX:+useparalleloldgc使用paralle收集器+老年代并行
4 cms收集器（并发标记清除）
重新标记还要整理
并发截断会降低吞吐量
老年代收集器，新生代用parnew
-XX:+useconmarkSweepgc
流程：
1初始标记：根可以直接关联的对象，速度快（非并发）
2并发标记：主要标记过程，标记全部对象（和用户线程一起）
3重新标记：由于并发标记时用户线程在运行，在标记一次修正（非并发）
4并发清除：基于标记结果进清除（和用户线程一起）
尽可能的降低停顿，
会影响整体的吞吐量和性能
比如：用户线程运行中，分一半cpu给gc，性能降低
清理不彻底：用户线程还在运行，会产生新垃圾
和用户线程一起运行，不能在空间快满的时候运行


