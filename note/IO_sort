ngix
netty
IO请求分为两路IO请求：：
1.磁盘---》拷贝内核
2.内核---》拷贝用户内存

NIO:有个缓冲区，不在是一个字节一个字节的拿数据，有个缓冲区的概念，另外直接内存可直接dma到disk
NIO非阻塞是因为，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。

轮询方式

如果将套接字读操作换成非阻塞的，那么只需要一个线程就可以同时处理套接字，每次检查一个套接字，有数据则读取，没有则检查下一个，因为是非阻塞的，所以执行read操作时若没有数据准备好则立即返回，不会发生阻塞。

 

I/O多路复用

这种轮询的方式缺点是浪费CPU资源，大部分时间可能都是无数据可读的，不必仍不间断的反复执行read操作，I/O多路复用（IOmultiplexing）是一种更好的方法，调用select函数时，其内部会维护一张监听的套接字的列表，其会一直阻塞直到其中某一个套接字有数据准备好才返回，并告诉是哪个套接字可读，这时再调用该套接字的read函数效率更高。

 

所以基本可以认为 “NIO = I/O多路复用 + 非阻塞式I/O”，大部分情况下是单线程，但也有超过一个线程实现NIO的情况



1)Non-blocking IO（非阻塞IO）
IO流是阻塞的，NIO流是不阻塞的。

Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。

Java IO的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了

2)Buffer(缓冲区)
IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。

Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。

在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。

最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。

3)Channel (通道)
NIO 通过Channel（通道） 进行读写。

通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。

4)Selectors(选择器)
NIO有选择器，而IO没有。

选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。



IO::全程阻塞
非阻塞IO：：用户进行请求，多次询问请求是否完成
复用性IO：：用户可以有多个请求，但实际IO还是会阻塞

nginx----------------底层原理
事件驱动IO：：异步，异步返回信号，请求是返回一个信号，等待数据完成后发送信号，阻塞内核---》用户空间
异步IO：：全程异步，两路IO全部结束在返回信号

bio的accept会阻塞，直到read和write会阻塞（线程明明没做事，却在阻塞，表示很忙）
NIO单线程selector轮询遍历执行（有请求才会执行。比如accept【accept在另外的线程（selector）】，read，write，有数据才处理），Buffer不在是一个字节一个字节的拿数据
一对多
aio异步IO：通知（accept不在阻塞了，基于事件通知，不在轮询）read也是（windows是事件通知的）
aio和nio都是epoll（linux底层AIO多了一层封装，windows才是异步的通知）
轮询（select和poll是检测所有的fd，epoll检测活跃的fd，当活跃fd接近注册的fd时，效率就会和poll和select差不多，）但读写都是同步阻塞的？
aio是检测内核和应用程序共享的区域的fd是否有数据，但是不能实时检测，要设置sleep时间（不如NIO）

NIO+多路复用IO：：NIO负责让网络不在阻塞，多路复用负责告诉操作系统那些数据需要处理（操作系统提供的一种通知机制）

、Netty是一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持，

作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，

通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。

NIObug	netty优点
p2p：客户端对客户端





