什么是索引？：：where后面的条件和orderby语句的排序   

索引是数据结构，排好序的快速查找数据结构---排序和查找
数据本身之外，数据库还维护这一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引 BTREE
频繁的增删数据会重新建立索引
一般来说索引本身很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在 磁盘上

优势：雷士大学图书管建立书目索引，提高数据检索的效率，降低数据库的IO成本
通过索引列对数据进行排序，降低数据排序的成本，降低cpu的消耗

劣势：：索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占空间的
索引提高了查询速度，但是在增删改更新时，不仅有数据的变更，还要保存一下索引文件每次更新增加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息
索引只是提高效率的一个因素，如果你的mysql有大数据量的表，就需要花时间研究建立最优秀的索引

索引的分类--（如果有很多索引，只能挑一个用）
1.单值索引————即一个索引只包含单个列，一个表可以有多个单列索引
2.唯一索引的值必须唯一，但允许有空值
3.复合索引即一个索引包含多个列

mysql索引结构：：
BTree结构
Hash结构
full-text全文索引
R—Tree索引	


那些情况需要建立索引：：
1.主键自动建立唯一索引	
2.频繁作为查询条件的字段应该创建索引
3.查询中与其他表关联的字段，外检关系建立索引
4.频繁更新的字段不适合创建索引
5.where条件里用不到的字段不创建索引
6.单键/组合索引的选择，（在高并发下倾向创建组合索引）
7.查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
8.查询中统计或者分组字段

不需要创建索引：：
1.表记录太少（300万）
2。经常增删改
3.重复且且平均的字段不建索引（性别）

分析：：
Explain+SQL语句---执行计划包含的信息
explain的表头：：
id /select_type /table/type/possible_keys/key/key_len/ref/rows/Extra


id：：：
select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序
id相同，执行顺序由上至下
id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
id相同不同，同时存在。先优先级高的，在由上到下

select
simple简单的select查询，查询中不包含子查询或者union
primary 查询中最外层的，最后被加载的
subquery在select或where列表中包含了子查询
derived在from列表中包含的子查询被标记为derived（衍生），mysql会递归执行这些子查询，把结果放在临时表里
union若第二个select出现在union之后，则被标记为union
若union包含在from子句的子查询中，外层select将被标记为derived
union result 两个union合并的结果集，在最后执行。

table是显示这一行数据是哪个表

type
从最好到最坏
system->const->eq_ref->ref->range->index->All
一般来说，得保证查询至少达到range级别，最好能达到ref
system：表只有一行记录





