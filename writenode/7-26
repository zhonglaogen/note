java:nio是select
netty是epoll

js：
cs要下载，产生bs
javaapplet在浏览器里
ecmascript（语言模版）
闭包a=fun(){
return fun(){}}
var b=new a();
b()
封装：this谁都可以调，没有私有
继承:Stu.prototype=new Person，把person内存放到stu
var s=new Stu()
找最近的，dis调stu的
var p
var s
p.dis.apply(s,[1,2]);把s的构造给p
call（s，1,2）；
bind（s，1,2）（）；返回一个函数，在调用
可变多参数，arguments
a(1,2,3,4,5,6)
arguments[i]

{
	name:xxx,
	id:1,
	dis:function{
		console.log(this.name,this.id)	
	}	
}



eval挂马img的返回js代码
里面访问外面：js
外面不能访问里面的：js



body的属性onload，html加载完调用函数
js自己贴代码
浏览器，开窗口开线程，资源共享
ajax异步，开另外一个线程，返回结果
json的key不要写引号，
ajax不能上传文件：
form的form的target为ifram的name；
ifram闪，回调主页面

etl

Apache开源，随便用，标注署名
GPL商业
gun，必开redhat有插件，centos
字段去掉所有
spoon
（LDAP）
启动ktr文件pan.sh
服务端：carte.sh
job：kichen
分区

每个都是线程
直接执行ktr文件
kjb流程 kichen
kattle 3.2.5
job-step

～～～～～～jsp ，打包，
反向代理(反向代理，是把一些静态资源存储在服务器上，当用户有请求的时候，就直接返回反向代理服务器上的资源给用户，而如果反向代理服务器上没有的资源，就转发给后面的负载均衡服务器，负载均衡服务器再将请求分发给后端的web服务器。        
区别就是：反向代理服务器是需要存储资源的，让用户更快速的接收到资源    负载均衡就是，为了保证后端web服务器的高可用，高并发，是不需要要存储资源，只需要转发用户的请求。)，
隧道，分页，p2p打洞
scp能拉数据
plu，jobnetis加插件

lvs三层
七层反向代理nginx
mfs不能root，分地方存，部分快
fastdfs
nfs           -》fuse（效率低），可以mount

drbd sync
 keepalibed  

lvs{
nat：负载均衡，内外网隔离，压力大（小规模）适合外网
tun隧道网卡
dr二层mac层，路由器ip欺骗，改mac，改lo
}
路由器ip欺骗

lvs
lvs隧道技术：网卡要支持，效率低要脱皮
http封一个tcp

wrr权重算法


