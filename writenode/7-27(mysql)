～jit 锁 聚非聚集 r树 select for update
mysql三大缓存：（RDBMS）
1.sql语句编译成机器码，会缓存，下次一样就用缓存
2.集合操作，暂存中间表
3.缓存结果

两种数据：
1事实：（时间）没有修改价值，购物，时间可以重复发生
2维度：（出生）缓慢变化维（性别），快速变化维度
维度：多对多

关系，关系
半关系，一张表
非关系（缓存）kv

mysql引擎

jdbc对外api
	^
4数据管理（元数据）|权限管理
	^
3sql解析器（sqlAPI）
	^
解耦和(不同语言，不能同时用)
	^
二维表kv+hash+list
	^
2RDB，api
	^
1底层文件系统（kv）开放api（增删改查）DB			引擎（（存储结构）随便换）
1.memory，块，小， 表锁，悲观锁，中断 infor表（字段，配置信息）
2.myisam，内存满了，就写成文件，内存（随机），disk（顺序），修改数据，整个表都锁死了  表锁，悲观锁，中断，mysql表（存的是用户权限）
DDL，发生的少，可以慢
DML'
3.Innodb：索引（b树，b+树）b树多叉，b+叶子链表慢，b×所有都是链表，快，行锁，索引，死锁（A操作1,2数据，B操作2,1数据，死锁）

find遍历
search搜索
index索引
匹配match

事物的隔离级别：脏读（读到其他没提交的事物）
		不可重复读（第一次没读到，第二次读到其他事物修改的值）
		幻读（第二次读到数据条数和第一次读到的不同）

1.read uncommit
2.read commiit 幻读 
3.repeat mysql(有重合报错)
4.serialize


buffer缓冲：先写内存，在写文件
cache缓存：数据写在内存


事物有原子性，可回滚
批处理没有，不可回滚
持久性：redo重做，undo撤销，日志

mvcc多版本控制：每行数据都由时间戳，数据提交按时间先后顺序来提交

正常吧有用数据放入缓存
where 1=1无优化 把所有数据都写入缓存，内存崩溃


setfetchsize（）；每次指定数据条数(数据库取)，
setMaxROws（）；拿指定条数

mysql要一条一条的反

不用。。触发器：执行操作前后做点操作
不用。。存储过程：远程调用函数，无返回类型
不用。。mysql视图存的是sql，
Oracle：真正的视图，插入数据变成真的表

b+树，建索引查快，但是改和删增慢
hash索引，
range索引（范围）
bitmap索引（Oracle）
优化：
show processlist 相当于ps-ef
mysql执行语句生成线程，以前生成进程
Oracle存在队列中，拿线程去执行,没有自增，有sequence序列
partion（分两个文件）改成文件夹，mount

